import heapq
import sys

"""
UNITS - список кортежей, где каждый кортеж представляет определенный предмет.
Характеристики предмета:
    - Добавление в час. Обозначает, на сколько повыситься доход после покупки этого предмета.
    - Стоимость. Обозначает стоимось, необходимую для покупки предмета.
    - Название. Обозначает названия предмета. Используется для удобного вывода результата вычислений.
По умолчанию, UNTIS содержит предметы, доступные в игре "Клюкер" от Яндекса.
После покупки предмета, обновите информацию о предмете в UNITS.
"""
UNITS: list[tuple[float, float, str]] = [
    (1_960, 50_000, 'Бегущий по Плюсу'), (2_360, 50_000, 'Листинг'),
    (147, 42_820, 'Голубиное кабаре'), (210, 42_820, 'Маскарад'),
    (676, 104_940, 'Финансовая грамота'), (113, 64_580, 'Философский булыжник'),
    (393, 106_180, '24 на 7'), (338, 100_910, 'Козырное местечко'),
    (189, 59_950, 'Олимпийка'), (1_280, 531_700, 'Стильный черный пакет'),
    (316, 85_650, 'Голубильдер'), (315, 56_510, 'Цацка'),
    (421, 128_480, 'Кормящая рука'), (723, 199_800, 'Спа-набор'),
    (984, 235_960, 'Секретный сейф'), (232, 55_670, 'Пероплан'),
    (492, 70_780, 'Космобатут'), (984, 353_940, 'Журнал с анектодами'),
    (1_350, 322_910, 'Клюк да Винчи'), (1_890, 428_270, 'Покатушки'),
    (2_950, 589_900, 'Чистый памятник'), (3_930, 1_170_000, 'VR-Кандибобер'),
    (842, 235_540, 'В самый раз'), (1_890, 342_610, 'Зерновой прогноз'),
]


class StrategyCalculation:
    """
    Позволяет определять наилучшую возможную покупку предмета,
    из списка предметов. Использует бинарную кучу для расчета результатов.
    В вычислении используеться расчет 2 коэфицентов:
        - Коэфицент окупаемости.
        - Коэфицент прибыльности.
    """
    def __init__(self) -> None:
        self.heap: list[tuple[float, float, str]] = []

    def adds_items(self, items: list[tuple[float, float, str]]) -> None:
        """
        Добавляет список предметов в хранилище класса.
        На вход ожидается аналогичный UNITS набор данных.
        """
        for item in items:
            value_per_hour, cost, name = item
            value_to_cost_ratio: float = value_per_hour / cost
            cost_to_value_ratio: float = cost / value_per_hour
            slot: tuple[float, float, str] = (
                -value_to_cost_ratio, cost_to_value_ratio, name
            )
            heapq.heappush(self.heap, slot)

    def whats_buy_next(self) -> str:
        """
        Выводит наилучшую покупку, которую можно осуществить на заданном наборе данных.
        Если набора данных нет, то выбрасывает исключение IndexError.
        Выходные данные - строка, обозначающая имя предмета.
        """
        if not self.heap:
            raise IndexError(
                "Нечего купить! Пожалуйста, добавь предметы в UNITS"
            )
        return self.heap[0][2]

    def best_5_items(self) -> list[str]:
        """
        Выводит 5 лучших покупок, которые можно осуществить на заданном наборе данных.
        Если набора данных нет, то выбрасывает исключение IndexError.
        Если набора данных содержит меньше 5 предметов, то функция вернет все доступные предметы.
        Выходные данные - список строк, где строка обозначет имя предмета.
        Список отсортирован в порядке убывания, от самый выгодной покупки до мнее выгодных предметов.
        """
        output: list[str] = []
        for _ in range(min(5, len(self.heap))):
            output.append(heapq.heappop(self.heap)[2])
        return output


if __name__ == '__main__':
    strategy: StrategyCalculation = StrategyCalculation()
    strategy.adds_items(UNITS)
    sys.stdout.write('Наилучший вариант для покупки - ')
    sys.stdout.write(strategy.whats_buy_next() + '\n')
    sys.stdout.write('-' * 15 + '\n')
    sys.stdout.write('Топ 5 лучших вариантов для покупки:\n')
    for choice in strategy.best_5_items():
        sys.stdout.write(choice + '\n')
